package com.shilovi.drones.service.drones.impl;

import com.shilovi.drones.config.properties.DroneProperties;
import com.shilovi.drones.dao.access.DronesAccessService;
import com.shilovi.drones.exception.DroneUnavailableException;
import com.shilovi.drones.exception.NotFoundException;
import com.shilovi.drones.model.BatteryLevelDto;
import com.shilovi.drones.model.DroneDto;
import com.shilovi.drones.service.drones.DronesClient;
import com.shilovi.drones.service.drones.DronesService;
import com.shilovi.drones.utils.tag.UnitTest;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.Random;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@UnitTest
class DronesServiceImplTest {

    private AutoCloseable closeable;

    DronesService service;

    @Mock
    private DronesAccessService accessService;
    @Mock
    private DronesClient client;
    @Mock
    private DroneProperties properties;

    private DroneDto dto;
    private String droneSerialNumber;
    private String brokenDroneSerialNumber;
    private String notExistentDroneSerialNumber;
    int batteryLevel;

    @BeforeEach
    void setUp() {
        closeable = MockitoAnnotations.openMocks(this);
        //serial numbers can be generated by randomizer
        droneSerialNumber = "droneSerialNumber";
        brokenDroneSerialNumber = "brokenDroneSerialNumber";
        notExistentDroneSerialNumber = "notExistentDroneSerialNumber";
        dto = DroneDto.builder()
                .serialNumber(droneSerialNumber)
                .build();
        when(accessService.save(dto)).thenReturn(dto);
        when(accessService.doesDroneExists(droneSerialNumber)).thenReturn(true);
        when(accessService.doesDroneExists(brokenDroneSerialNumber)).thenReturn(true);
        when(accessService.doesDroneExists(notExistentDroneSerialNumber)).thenReturn(false);
        batteryLevel = new Random().nextInt(101);
        when(client.getBatteryLevel(droneSerialNumber)).thenReturn(batteryLevel);
        when(client.getBatteryLevel(brokenDroneSerialNumber)).thenThrow(new RuntimeException("Request timeout!"));
        service = new DronesServiceImpl(accessService, client, properties);
    }

    @AfterEach
    void tearDown() throws Exception {
        closeable.close();
        service = null;
    }

    @Test
    void register() {
        assertEquals(dto, service.register(dto));
        verify(accessService, only()).save(dto);
    }

    @Test
    void checkBatteryLevel() {
        BatteryLevelDto dto = service.checkBatteryLevel(droneSerialNumber);
        assertAll(() -> assertEquals(batteryLevel, dto.getBatteryLevel()),
                () -> assertEquals(droneSerialNumber, dto.getSerialNumber()));
        verify(client, only()).getBatteryLevel(droneSerialNumber);
    }

    @Test
    void checkBatteryLevelUnavailableException() {
        assertThrows(DroneUnavailableException.class, ()-> service.checkBatteryLevel(brokenDroneSerialNumber));
    }

    @Test
    void checkBatteryLevelNotFoundException() {
        assertThrows(NotFoundException.class, ()-> service.checkBatteryLevel(notExistentDroneSerialNumber));
    }

}